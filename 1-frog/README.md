Difficulity level - **super easy** and **Newbie friendly** , not so educational. 

Many ways to solve, here are a few with their pros and cons:

1. Since this is a 2d game "compiled" into an `.exe` , we can play the game (trial and error)and win in about 2 minutes- **works in short time since game board is small**, but not scaleable/transferable to a larger game/realistic problem - the keep it simple stupid (kiss) method
2. Patch/edit the game source code `frog.py` and run it (play the game with cheats) after installing the package `pygame`. It is also a good idea to look for "flag" case-insensitive in the code
    1. Transform all blocks to virutally passable - **Wallhack** 
        1. By removing the "exit" (return false) condition on the coordinate location - see [Washi writeup](https://washi1337.github.io/ctf-writeups/writeups/flare-on/2024/1/) and [0xdf blog](https://0xdf.gitlab.io/flare-on-2024/frog)
        2. By modifiying the init value for passable to `self.passable = passable` inside the Block class constructor (ctor) body (change at one spot instead of at many lines)
    2. After understanding the source code logic and noticing `victory_tile = pygame.Vector2(10, 10)`, we can simply call the flag text content generation function with the hardcoded coordinates of the victory destination `GenerateFlagText(10, 10)` - Lets us grab and run only the deciphering code without running the whole game! see [SuperFashi writeup](https://gmo-cybersecurity.com/blog/flare-on-11-write-up/) or [Simple solver code](https://github.com/hasherezade/flareon2024/blob/main/task1/sol1.py) - **Probably the most elegant solution**
    3. Remove some/all walls by commenting out/removing calls to ctor - see [ispoleet writeup](https://github.com/ispoleet/flare-on-challenges/tree/master/flare-on-2024/01_frog)
    4. Probably a "not worth it" method- make the passable blocks graphically distinguished from the rest (such as providing different image/icon source for them) see [official writeup](https://services.google.com/fh/files/misc/flare-on11-challenge1-frog.pdf)

3. Noticing that the flag is generated by xoring a one byte key (dependent on coordinate input to `GenerateFlagText()` with a fixed bytearray)
   1. Bruteforce the key and inspect the output untill we find a meaningfull flag
      1. With a tool like `Cyberchef` (gui) -see [SuperFashi writeup](https://gmo-cybersecurity.com/blog/flare-on-11-write-up/)  or `Binary Refinery` (very cool cli tool, but not so intuitive)
      2. With a small script for printing all options - see [Jinmo123 video](https://youtu.be/WLSZPC5ZagY?t=68)
      3. **How not to do it** (overcomplicating) - [vaktibabat blog](https://vaktibabat.github.io/posts/flareon2024/) - it's enough to limit key to a size of byte since the xor is byte by byte and the result must be in the ascii printable range (0-256 for unsigned char/byte), so defenitely no need for multithreading in this case. But anyhow, this kid looks quite promising and very smart.
   2. Plaintext attack - we know the suffix of the flag `"@flare-on.com"`, we just need to xor it (bytewise) with the equivalent length of suffix of the encoded flag bytes. see [SuperFashi writeup](https://gmo-cybersecurity.com/blog/flare-on-11-write-up/).  since key length is one byte it is enough to xor only one index from each. then just apply xoring the key with the rest of the encoded flag bytes 

